<script>
  // 元素缓存
  const sourceText = document.getElementById('sourceText');
  const proxyAddr = document.getElementById('proxyAddr');
  const resultText = document.getElementById('resultText');
  const processBtn = document.getElementById('processBtn');
  const copyBtn = document.getElementById('copyBtn');
  const clearBtn = document.getElementById('clearBtn');

  // 默认 proxy（可修改）
  const DEFAULT_PROXY = '192.168.1.100:4022';

  // 更稳健的正则：匹配 ChannelName, UserChannelID, ChannelURL="protocol://rest"
  // 能容忍空格、不同顺序中常见的逗号空白等
  const lineRegex = /ChannelName\s*=\s*"([^"]+)"\s*,\s*UserChannelID\s*=\s*"([^"]+)"\s*,\s*ChannelURL\s*=\s*"([^:"]+):\/\/([^"]+)"/gi;

  // 处理按钮
  processBtn.addEventListener('click', () => {
    const source = sourceText.value.trim();
    const proxy = proxyAddr.value.trim() || DEFAULT_PROXY;

    if (!source) { alert('请先粘贴原始节目列表！'); return; }

    // 放宽 proxy 校验：允许 IPv4/hostname（含点/字母）和端口；简单校验即可
    if (!/^[\w\.\-:]+:\d+$/.test(proxy)) {
      alert('代理地址格式错误（需为 host:port，例如 192.168.1.100:4022 或 proxy.local:4022）！');
      return;
    }

    // 使用回调替换，以便根据 protocol 动态生成 proxy URL
    let replacedCount = 0;
    const body = source.replace(lineRegex, (match, channelName, userId, protocol, rest) => {
      replacedCount++;
      // 根据协议生成代理路径（常见：udp -> /udp/<rest>）
      const lowProto = protocol.toLowerCase();
      let proxiedUrl;
      if (lowProto === 'udp') {
        // udpxy 常用格式： http://<proxy>/udp/<multicast-ip>:<port>
        proxiedUrl = `http://${proxy}/udp/${rest}`;
      } else if (lowProto === 'rtsp') {
        // 假如想通过 proxy 转发 rtsp，可以用 /rtsp/ 占位（视你的代理实现）
        proxiedUrl = `http://${proxy}/rtsp/${rest}`;
      } else if (lowProto === 'http' || lowProto === 'https') {
        // 对于已有 http(s) 链接，直接保留协议并把 host/path 拼上（或走 proxy 的相应路径）
        proxiedUrl = `${protocol}://${rest}`;
      } else {
        // 其他协议，保守处理：把原始 rest 放到 proxy 的通用路径下
        proxiedUrl = `http://${proxy}/${lowProto}/${rest}`;
      }

      // 生成一条 M3U 条目
      // 我只把频道名写入 EXTINF（也可以带更多属性）
      return `#EXTINF:-1,${channelName}\n${proxiedUrl}`;
    });

    if (replacedCount === 0) {
      // 没有替换到任何条目：提示并把原文输出（或只输出空）
      if (!confirm('没有匹配到任何频道条目。是否将原始内容输出为注释？(点击取消将保留结果为空)')) {
        resultText.value = '';
        return;
      }
      resultText.value = '#EXTM3U\n' + source;
      return;
    }

    // 构造最终 M3U，去重连续多余换行
    const finalM3U = '#EXTM3U\n' + body.trim().replace(/\n{2,}/g, '\n');
    resultText.value = finalM3U;
    alert(`转换完成，共处理 ${replacedCount} 个条目。`);
  });

  // 复制结果：优先 navigator.clipboard，其次回退到 textarea 选中复制
  copyBtn.addEventListener('click', async () => {
    const result = resultText.value.trim();
    if (!result) { alert('暂无转换结果可复制！'); return; }

    // 尝试 modern API
    if (navigator.clipboard && navigator.clipboard.writeText) {
      try {
        await navigator.clipboard.writeText(result);
        alert('结果已复制到剪贴板（navigator.clipboard）！');
        return;
      } catch (err) {
        // 继续到回退方式
      }
    }

    // 回退方式：临时选中 textarea，执行 execCommand
    try {
      resultText.removeAttribute('readonly'); // 允许选中
      resultText.select();
      resultText.setSelectionRange(0, resultText.value.length);
      const ok = document.execCommand('copy');
      resultText.setAttribute('readonly', 'readonly');
      if (ok) {
        alert('结果已复制到剪贴板（回退方式）！');
      } else {
        throw new Error('execCommand copy 返回 false');
      }
    } catch (err) {
      alert('复制失败，请手动选中并复制。');
    }
  });

  // 清空：重置到默认 proxy
  clearBtn.addEventListener('click', () => {
    sourceText.value = '';
    resultText.value = '';
    proxyAddr.value = DEFAULT_PROXY;
    alert('已清空所有内容并重置代理地址！');
  });
</script>