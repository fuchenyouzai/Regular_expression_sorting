<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8">
  <title>IPTV节目列表正则处理工具 — 转 M3U</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <style>
    body { font-family: Arial, "Helvetica Neue", Helvetica, sans-serif; max-width: 1100px; margin: 22px auto; padding: 0 18px; color: #222; }
    h1 { margin: 6px 0 14px 0; font-weight: 700; color: #0b6; }
    .container { margin-bottom: 18px; }
    label { display:block; margin-bottom:8px; font-weight:600; }
    textarea { width:100%; min-height:180px; padding:10px; border:1px solid #ddd; border-radius:6px; box-sizing:border-box; resize:vertical; font-family: monospace; }
    input[type="text"] { padding:8px 10px; border-radius:6px; border:1px solid #ddd; width:320px; box-sizing:border-box; }
    button { padding:8px 14px; border-radius:6px; border:none; cursor:pointer; background:#0a7; color:#fff; margin-right:8px; font-weight:600; }
    button.ghost { background:#f3f3f3; color:#222; border:1px solid #ddd; }
    small.hint { color:#666; display:block; margin-top:6px; }
    #resultText[readonly] { background:#fafafa; }
    .row { display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
    .meta { font-size:13px; color:#666; margin-top:8px; }
    footer { margin-top:26px; color:#666; font-size:13px; text-align:center; }
    @media (max-width:600px) {
      input[type="text"]{ width:100%; }
      .row { flex-direction:column; align-items:flex-start; }
    }
  </style>
</head>
<body>
  <h1>IPTV节目列表 → M3U 格式转换工具</h1>

  <div class="container">
    <label for="sourceText">1. 粘贴原始 IPTV 节目列表（每行一个条目，支持任意字段顺序）：</label>
    <textarea id="sourceText" placeholder='示例：ChannelName="CCTV1",UserChannelID="1001",ChannelURL="udp://239.1.1.1:1234".timeExtra
ChannelURL="http://media.example.com/path/stream.m3u8",ChannelName="BBC",UserChannelID="2002"
ChannelName="MyRTSP", ChannelURL="rtsp://192.168.2.50/stream", UserChannelID="3003"'></textarea>
    <small class="hint">工具会按每行解析 key="value" 形式的字段（例如 ChannelName、UserChannelID、ChannelURL）。当找不到 ChannelName 或 ChannelURL 时该行会被跳过。</small>
  </div>

  <div class="container">
    <label for="proxyAddr">2. udpxy / 代理地址（host:port，可用主机名或 IP）：</label>
    <input type="text" id="proxyAddr" value="192.168.1.100:4022" placeholder="例如 192.168.1.100:4022 或 proxy.local:4022">
    <div class="meta">默认对于 <code>udp://</code> 协议会生成 <code>http://&lt;proxy&gt;/udp/&lt;multicast:port&gt;</code>；其它协议按规则保留或经代理路径转换。</div>
  </div>

  <div class="container row">
    <button id="processBtn">执行转换</button>
    <button id="copyBtn" class="ghost">复制结果</button>
    <button id="clearBtn" class="ghost">清空并重置</button>
    <button id="exampleBtn" class="ghost">插入示例</button>
  </div>

  <div class="container">
    <label for="resultText">3. 处理后的 M3U 列表：</label>
    <textarea id="resultText" readonly placeholder="点击 '执行转换' 后这里会显示转换结果..."></textarea>
    <small class="hint">如果转换未匹配到任何条目，工具会提示并允许将原文以注释形式输出。</small>
  </div>

  <footer> https://t.me/fuchenyouzaibot 悠哉TG @fuchenyouzaibot</footer>

  <script>
  (function(){
    // 元素
    const sourceText = document.getElementById('sourceText');
    const proxyAddr = document.getElementById('proxyAddr');
    const resultText = document.getElementById('resultText');
    const processBtn = document.getElementById('processBtn');
    const copyBtn = document.getElementById('copyBtn');
    const clearBtn = document.getElementById('clearBtn');
    const exampleBtn = document.getElementById('exampleBtn');

    const DEFAULT_PROXY = '192.168.1.100:4022';

    // 将一行解析成键值对象：匹配 key="value" 的所有项
    function parseLineToKV(line) {
      const re = /([\w\-]+)\s*=\s*"([^"]*)"/g;
      const kv = {};
      let m;
      while ((m = re.exec(line)) !== null) {
        const key = m[1].trim();
        const val = m[2];
        kv[key] = val;
      }
      return kv;
    }

    // 生成最终代理化/原样 URL
    function makeProxiedUrl(rawUrl, proxyHostPort) {
      // rawUrl 可能像 "udp://239.1.1.1:1234" 或 "http://..." 或 "rtsp://..."
      try {
        // 尝试用 URL 解析（对非 http(s) 也能得到 protocol + rest）
        // 为了兼容 rtsp/udp 等，先用 regex 如果 URL 构造失败
        const protoMatch = rawUrl.match(/^([^:]+):\/\/(.+)$/);
        if (!protoMatch) {
          // 无协议 -> 直接返回原串
          return rawUrl;
        }
        const proto = protoMatch[1].toLowerCase();
        const rest = protoMatch[2];

        if (proto === 'udp') {
          // udpxy 常见路径： http://<proxy>/udp/<multicast-ip>:<port>
          return `http://${proxyHostPort}/udp/${rest}`;
        } else if (proto === 'rtsp') {
          // rtsp 可能需要代理或特殊处理，默认走 proxy 下的 rtsp 路径（请根据你的代理调整）
          return `http://${proxyHostPort}/rtsp/${rest}`;
        } else if (proto === 'http' || proto === 'https') {
          // http/https 保持原样（通常不需要通过 udpxy）
          return rawUrl;
        } else {
          // 其它协议保守处理：放到 proxy 的通用路径下
          return `http://${proxyHostPort}/${proto}/${rest}`;
        }
      } catch (e) {
        return rawUrl;
      }
    }

    // 主处理函数（逐行解析）
    function processSource(source, proxy) {
      const lines = source.split(/\r?\n/).map(l => l.trim()).filter(l => l.length > 0);
      const outEntries = [];
      let processedCount = 0;

      for (const line of lines) {
        const kv = parseLineToKV(line);

        // 容错：尝试兼容历史可能的命名（如 xxxChannelName）
        const channelName = kv.ChannelName || kv.ChannelNAme || kv.channelName || kv.Channel || kv.xxxChannelName || '';
        const userId = kv.UserChannelID || kv.userChannelID || kv.UserChannel || kv.ChannelID || '';
        let channelUrl = kv.ChannelURL || kv.ChannelUrl || kv.channelURL || kv.URL || '';

        // 有些行可能把 URL 放在其它字段或后缀中，尝试粗略抽取 "proto://rest" 的部分
        if (!channelUrl) {
          const urlMatch = line.match(/([a-zA-Z0-9]+):\/\/[^\s,"]+/);
          if (urlMatch) channelUrl = urlMatch[0];
        }

        if (!channelUrl) {
          // 无法找到 URL，跳过
          continue;
        }
        if (!channelName) {
          // 若缺少频道名，用 URL 作为名称备选（去掉协议）
          const fallbackName = channelUrl.replace(/^[a-zA-Z0-9]+:\/\//, '');
          // 取到第一段作为名（避免过长）
          kv._fallbackName = fallbackName.split(/[\/:\?]/)[0] || fallbackName;
        }

        const finalName = channelName || kv._fallbackName || 'UnnamedChannel';
        const proxied = makeProxiedUrl(channelUrl, proxy);

        // 输出带 tvg-id 的 EXTINF（若有 UserChannelID）
        if (userId) {
          outEntries.push(`#EXTINF:-1 tvg-id="${userId}" tvg-name="${finalName}",${finalName}`);
        } else {
          outEntries.push(`#EXTINF:-1,${finalName}`);
        }
        outEntries.push(proxied);
        processedCount++;
      }

      return { processedCount, m3u: '#EXTM3U\n' + outEntries.join('\n') + (outEntries.length ? '\n' : '') };
    }

    // 按钮事件
    processBtn.addEventListener('click', () => {
      const source = sourceText.value.trim();
      const proxy = (proxyAddr.value.trim() || DEFAULT_PROXY).trim();

      if (!source) { alert('请先粘贴原始节目列表！'); return; }
      if (!/^[\w.\-]+:\d+$/.test(proxy)) {
        alert('代理地址格式错误（请使用 host:port，例如 192.168.1.100:4022 或 proxy.local:4022）');
        return;
      }

      const res = processSource(source, proxy);
      if (res.processedCount === 0) {
        const ok = confirm('未匹配到任何频道条目。是否将原始内容以注释形式输出为 M3U（取消则结果置空）？');
        if (ok) {
          resultText.value = '#EXTM3U\n' + source.split(/\r?\n/).map(l => '# ' + l).join('\n') + '\n';
        } else {
          resultText.value = '';
        }
        return;
      }

      resultText.value = res.m3u;
      alert(`转换完成：共处理 ${res.processedCount} 个条目。`);
    });

    // 复制（优先 navigator.clipboard，次级回退 execCommand）
    copyBtn.addEventListener('click', async () => {
      const text = resultText.value;
      if (!text) { alert('暂无转换结果可复制！'); return; }

      if (navigator.clipboard && navigator.clipboard.writeText) {
        try {
          await navigator.clipboard.writeText(text);
          alert('结果已复制到剪贴板（现代 API）！');
          return;
        } catch (err) {
          // 继续回退
        }
      }

      try {
        resultText.removeAttribute('readonly');
        resultText.select();
        resultText.setSelectionRange(0, resultText.value.length);
        const ok = document.execCommand('copy');
        resultText.setAttribute('readonly', 'readonly');
        if (ok) {
          alert('结果已复制到剪贴板（回退方式）！');
        } else {
          throw new Error('execCommand 返回 false');
        }
      } catch (e) {
        alert('复制失败，请手动选中文本并复制。');
      }
    });

    // 清空重置
    clearBtn.addEventListener('click', () => {
      if (!confirm('确定要清空并重置为默认代理吗？')) return;
      sourceText.value = '';
      resultText.value = '';
      proxyAddr.value = DEFAULT_PROXY;
      alert('已清空并重置代理。');
    });

    // 插入示例
    exampleBtn.addEventListener('click', () => {
      sourceText.value = [
        'ChannelName="CCTV1",UserChannelID="1001",ChannelURL="udp://239.1.1.1:1234".timexxx',
        'ChannelURL="http://media.example.com/path/stream.m3u8",ChannelName="BBC",UserChannelID="2002"',
        'ChannelName="MyRTSP", ChannelURL="rtsp://192.168.2.50/stream", UserChannelID="3003"',
        'xxxChannelName="WRONG",UserChannelID="4004",SomeField="no url here"'
      ].join('\\n');
      alert('示例已插入，点击 "执行转换" 查看效果。');
    });

    // 页面加载时可选地填入示例（不自动插入）
  })();
  </script>
</body>
</html>